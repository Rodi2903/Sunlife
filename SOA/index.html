<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SOA Generator</title>
    <link rel="shortcut icon" href="sun-life-logo.png" type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Add jsPDF and html2canvas libraries for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            margin: 20px;
        }
        .container {
            max-width: 600px;
            width: 100%;
            margin: auto;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        .header {
            background: #073763;
            color: white;
            padding: 10px;
            text-align: center;
            border-radius: 8px 8px 0 0;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: inline-block;
            width: 200px;
            font-weight: bold;
        }
        .form-control {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 250px;
        }
        button {
            background: #073763;
            color: white;
            border: 2px solid #073763;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        button:hover {
            background: #052745;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            padding: 10px;
            text-align: left;
            border: 1px solid #ddd;
        }
        th {
            background: #073763;
            color: white;
        }
        tr:nth-child(even) {
            background-color: #e6f2ff;
        }
        .account-summary {
            background-color: #d6e9ff;
            padding: 10px;
            margin-bottom: 20px;
        }
        .account-summary h3 {
            text-align: center;
            margin-top: 0;
            background-color: #a3c9ff;
            padding: 5px;
        }
        .summary-row {
            display: flex;
            margin-bottom: 10px;
        }
        .summary-label {
            width: 60%;
        }
        .summary-value {
            width: 40%;
            text-align: right;
        }
        .paid {
            color: green;
            font-weight: bold;
        }
        .not-paid {
            color: red;
            font-weight: bold;
        }
        .partial-paid {
            color: orange;
            font-weight: bold;
        }
        .future-due {
            font-style: italic;
        }
        
        /* PDF specific styles */
        #pdf-container {
            display: none;
            width: 8.5in;
            padding: 0.5in;
            font-family: 'Calibri', sans-serif;
            font-size: 12pt;
            color: black;
            background-color: white;
        }
        .pdf-header {
            width: 95%;
            background-color: #073763;
            padding: 20px;
            text-align: center;
        }
        .pdf-header img {
            max-width: 100%;
            height: auto;
            display: inline-block;
        }
        .pdf-title {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            background-color: #d6e9ff;
            color: black;
            padding: 5px;
        }
        .pdf-client-info {
            margin-bottom: 5px;
            line-height: 1.5;
        }
        .pdf-summary {
            display: flex;
            justify-content: space-between;
        }
        .pdf-summary-left {
            width: 50%;
        }
        .pdf-summary-right {
            width: 50%;
            text-align: right;
        }
        .pdf-table {
            width: 100%;
            border-collapse: collapse;
        }
        .pdf-table th, .pdf-table td {
            border: none;
            padding: 8px;
            text-align: left;
        }
        .pdf-table th {
            background-color: #073763;
            color: white;
        }
        .pdf-table .separator-row {
            background-color: #d6e9ff;
            height: 4px;
        }
        .pdf-table .data-row {
            background-color: white;
        }
        .pdf-table .paid, .pdf-table .not-paid, .pdf-table .partial-paid {
            color: black;
            font-weight: bold;
        }
        .pdf-table .future-due {
            font-style: italic;
        }
        
        /* Loading indicator */
        .loading {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            text-align: center;
            color: white;
        }
        .loading-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .spinner {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #073763;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 2s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Editable status cell styles */
        .editable-status {
            cursor: pointer;
            min-height: 20px;
            min-width: 100px;
            padding: 5px;
            border: 1px dashed transparent;
            position: relative;
        }
        .editable-status:hover {
            border: 1px dashed #073763;
            background-color: #f0f8ff;
        }
        .editable-status:focus {
            outline: none;
            border: 1px solid #073763;
            background-color: #f0f8ff;
        }
        .editable-status::after {
            content: "âœŽ";
            position: absolute;
            right: 5px;
            top: 5px;
            font-size: 12px;
            opacity: 0.5;
            color: #073763;
        }
        .editable-status:hover::after {
            opacity: 1;
        }
        
        /* Instruction box styles */
        .instruction-box {
            background-color: #f0f8ff;
            border-left: 4px solid #073763;
            padding: 10px 15px;
            margin: 15px 0;
            font-size: 14px;
            line-height: 1.5;
        }
        .instruction-box h4 {
            margin-top: 0;
            margin-bottom: 5px;
            color: #073763;
        }
        .instruction-box ul {
            margin: 5px 0;
            padding-left: 20px;
        }
        .instruction-box li {
            margin-bottom: 5px;
        }
        
        /* Lapsed policy styles */
        .lapsed-balance {
            color: red !important;
        }
        
        /* Status dropdown styles */
        .status-dropdown {
            padding: 3px;
            border: 1px solid #ccc;
            border-radius: 3px;
            background-color: white;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div style="margin-bottom:20px;" class="header">
            <h2>SOA Generator</h2>
        </div>

        <div class="form-group">
            <label>Client Name:</label>
            <input type="text" id="clientName" class="form-control" placeholder="Enter Client Full Name">
        </div>
        <div class="form-group">
            <label>Plan:</label>
            <input type="text" id="planName" class="form-control" placeholder="Enter Plan Name">
        </div>
        <div class="form-group">
            <label>Policy No:</label>
            <input type="number" id="policyNo" class="form-control" placeholder="Enter Policy Number">
        </div>
        
        <div class="form-group">
            <label>Policy Anniversary:<span style="color:red;">*</span></label>
            <input type="date" id="policyAnniversary" class="form-control" required>
        </div>
        <div class="form-group">
            <label>Total Paid for Whole Duration:<span style="color:red;">*</span></label>
            <input type="number" id="totalPaid" class="form-control" placeholder="Enter Total Payments Made" required>
        </div>
        <div class="form-group">
            <label>Premium Amount:<span style="color:red;">*</span></label>
            <input type="number" id="premiumAmount" class="form-control" placeholder="Enter Total Premium Amount" required>
        </div>
        <div class="form-group">
            <label>Mode of Payment:<span style="color:red;">*</span></label>
            <select id="modeOfPayment" class="form-control" required>
                <option value="quarterly">Quarterly</option>
                <option value="annual">Annual</option>
                <option value="monthly">Monthly</option>
            </select>
        </div>
        <div class="form-group">
            <label>Policy Status:</label>
            <select id="policyStatus" class="form-control">
                <option value="premium-paying">Premium Paying</option>
                <option value="lapsed">Lapsed</option>
            </select>
        </div>
        <div class="form-group">
            <label>Current Date:<span style="color:red;">*</span></label>
            <input type="date" id="currentDate" class="form-control" required>
        </div>

        <!-- <div class="form-group">
            <label>Upload Image:</label>
            <input type="file" id="imageUpload" accept="image/*" class="form-control">
        </div> -->

        <div class="form-group">
            <label>Header Image:</label>
            <select id="headerImageSource" class="form-control">
                <option value="default">Use Default Image</option>
                <option value="custom">Use Custom URL</option>
                <option value="upload">Upload Image</option>
            </select>
        </div>
        
        <div id="customUrlContainer" class="form-group" style="display: none;">
            <label>Custom Image URL:</label>
            <input type="text" id="headerImageUrl" class="form-control" value="https://hebbkx1anhila5yf.public.blob.vercel-storage.com/soa%20header%20image-GepdkJ5byUE9Jea1vECqLv65ibEkZK.png">
        </div>
        
        <div id="uploadImageContainer" class="form-group" style="display: none;">
            <label>Upload Header Image:</label>
            <input type="file" id="headerImageUpload" accept="image/*" class="form-control">
            <div id="previewContainer" style="margin-top: 10px; display: none;">
                <p>Preview:</p>
                <img id="headerImagePreview" style="max-width: 100%; max-height: 150px;">
            </div>
        </div>

        <!-- <button onclick="extractFromImage()">Extract from Image</button> -->
        <div align="right">
            <button style="margin-top:20px; background: #d6e9ff; color: #073763;" onclick="exportToPDF()"><b>Export to PDF</b></button>
            <button style="margin-top:20px;" onclick="generateSOA()"><b>GENERATE SOA</b></button>
        </div>

        <div id="output" style="margin-top: 30px;"></div>
    </div>

    <!-- Hidden container for PDF generation -->
    <div id="pdf-container">
        <div class="pdf-header">
            <img id="pdf-header-img" src="soa-header-image.png" alt="Sun Life Financial">
        </div>
        <div class="pdf-title">ACCOUNT SUMMARY</div>
        <div class="pdf-summary">
            <div class="pdf-summary-left">
                <div class="pdf-client-info"><strong>CLIENT'S NAME: <span id="pdf-client-name"></span></strong></div>
                <div class="pdf-client-info"><strong>Plan:</strong> <span id="pdf-plan"></span></div>
                <div class="pdf-client-info"><strong>Policy No:</strong> <span id="pdf-policy-no"></span></div>
                <div class="pdf-client-info"><strong>Policy Anniversary:</strong> <span id="pdf-anniversary"></span></div>
                <div class="pdf-client-info"><strong>Policy Status:</strong> <span id="pdf-policy-status"></span></div>
            </div>
            <div class="pdf-summary-right">
                <div></div><br>
                <div>Total paid for whole duration: &nbsp; &nbsp; &nbsp; <strong><span style="font-size: 15pt;" id="pdf-total-paid">PHP 0.00</span></strong></div><br>
                <div></div><br>
                <div><strong>Balance: &nbsp; &nbsp; &nbsp; <span style="font-size: 15pt;" id="pdf-balance">PHP 0.00</span></strong></div>
            </div>
        </div>
        <div class="pdf-title" style="color:#d6e9ff; margin-bottom:-20px;">ACCOUNT SUMMARY</div>
        <table class="pdf-table margin-top:0px;">
            <thead>
                <tr>
                    <th>Coverage Date</th>
                    <th>Premium Amount</th>
                    <th>Status</th>
                </tr>
            </thead>
            <tbody style="font-family: Arial, sans-serif; font-size: 10pt;" id="pdf-table-body">
                <!-- Will be populated dynamically -->
            </tbody>
        </table>
    </div>
    
    <!-- Loading indicator -->
    <div id="loading" class="loading">
        <div class="loading-content">
            <div class="spinner"></div>
            <p>Generating PDF...</p>
        </div>
    </div>

    <script>
        // Set current date as default and initialize UI
        document.addEventListener('DOMContentLoaded', function() {
            const today = new Date();
            document.getElementById('currentDate').value = formatDateForInput(today);
            
            // Set up header image source selection
            document.getElementById('headerImageSource').addEventListener('change', function() {
                const customUrlContainer = document.getElementById('customUrlContainer');
                const uploadImageContainer = document.getElementById('uploadImageContainer');
                
                if (this.value === 'custom') {
                    customUrlContainer.style.display = 'block';
                    uploadImageContainer.style.display = 'none';
                } else if (this.value === 'upload') {
                    customUrlContainer.style.display = 'none';
                    uploadImageContainer.style.display = 'block';
                } else {
                    customUrlContainer.style.display = 'none';
                    uploadImageContainer.style.display = 'none';
                }
            });
            
            // Set up header image upload preview
            document.getElementById('headerImageUpload').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const img = document.getElementById('headerImagePreview');
                        img.src = event.target.result;
                        document.getElementById('previewContainer').style.display = 'block';
                    };
                    reader.readAsDataURL(file);
                }
            });
            
            // Set up event delegation for editable status cells
            document.addEventListener('click', function(e) {
                if (e.target && e.target.classList.contains('editable-status')) {
                    makeEditable(e.target);
                }
            });
            
            // Set up policy status change event
            document.getElementById('policyStatus').addEventListener('change', function() {
                // If SOA is already generated, update the PDF container with the new policy status
                if (document.getElementById('output').innerHTML) {
                    updatePdfContainerPolicyStatus();
                }
            });
        });

        // Make a cell editable
        function makeEditable(cell) {
            // Create a dropdown for status options
            const dropdown = document.createElement('select');
            dropdown.className = 'status-dropdown';
            
            // Add common status options
            const options = [
                { value: 'PAID', text: 'PAID' },
                { value: 'NOT PAID', text: 'NOT PAID' },
                { value: 'FUTURE DUE', text: 'FUTURE DUE' }
            ];
            
            // Add the current value as an option if it's not in the list
            const currentValue = cell.textContent.trim();
            let hasCurrentValue = false;
            
            for (const option of options) {
                if (currentValue === option.text) {
                    hasCurrentValue = true;
                    break;
                }
            }
            
            if (!hasCurrentValue) {
                options.push({ value: currentValue, text: currentValue });
            }
            
            // Create option elements
            options.forEach(option => {
                const optionElement = document.createElement('option');
                optionElement.value = option.value;
                optionElement.textContent = option.text;
                
                if (option.text === currentValue) {
                    optionElement.selected = true;
                }
                
                dropdown.appendChild(optionElement);
            });
            
            // Add custom option at the end
            const customOption = document.createElement('option');
            customOption.value = 'CUSTOM';
            customOption.textContent = 'Custom...';
            dropdown.appendChild(customOption);
            
            // Clear the cell and add the dropdown
            cell.textContent = '';
            cell.appendChild(dropdown);
            
            // Focus the dropdown
            dropdown.focus();
            
            // Handle dropdown change
            dropdown.onchange = function() {
                if (this.value === 'CUSTOM') {
                    // Remove the dropdown
                    cell.removeChild(dropdown);
                    
                    // Make the cell editable with the original content
                    cell.contentEditable = true;
                    cell.textContent = currentValue;
                    cell.focus();
                    
                    // Set up blur and key events for the editable cell
                    setupEditableEvents(cell);
                } else {
                    // Set the cell text to the selected option
                    cell.textContent = this.value;
                    
                    // Update the PDF table
                    updatePdfTableWithEditedStatus();
                }
            };
            
            // Handle blur event for the dropdown
            dropdown.onblur = function() {
                // Set the cell text to the selected option
                cell.textContent = this.value;
                
                // Update the PDF table
                updatePdfTableWithEditedStatus();
            };
        }
        
        // Set up editable events for a cell
        function setupEditableEvents(cell) {
            // Save the original content to restore if needed
            cell.dataset.originalContent = cell.textContent;
            
            // Handle blur event to save changes
            cell.onblur = function() {
                cell.contentEditable = false;
                
                // Update the PDF table with the edited content
                updatePdfTableWithEditedStatus();
            };
            
            // Handle key events
            cell.onkeydown = function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    cell.blur();
                } else if (e.key === 'Escape') {
                    cell.textContent = cell.dataset.originalContent;
                    cell.blur();
                }
            };
        }
        
        // Update the PDF table with edited status values
        function updatePdfTableWithEditedStatus() {
            // Get all status cells from the visible table
            const statusCells = document.querySelectorAll('#output table tbody td.editable-status');
            const pdfTableRows = document.querySelectorAll('#pdf-table-body tr.data-row');
            
            // Update each PDF table row with the corresponding edited status
            for (let i = 0; i < Math.min(statusCells.length, pdfTableRows.length); i++) {
                const statusCell = pdfTableRows[i].querySelector('td:nth-child(3)');
                if (statusCell) {
                    statusCell.textContent = statusCells[i].textContent;
                }
            }
        }
        
        // Update the PDF container with the current policy status
        function updatePdfContainerPolicyStatus() {
            const policyStatus = document.getElementById('policyStatus').value;
            const policyStatusText = document.getElementById('policyStatus').options[document.getElementById('policyStatus').selectedIndex].text;
            
            // Update the policy status text in the PDF
            document.getElementById('pdf-policy-status').textContent = policyStatusText;
            
            // Update the balance amount color based on policy status
            const balanceElement = document.getElementById('pdf-balance');
            
            if (policyStatus === 'lapsed') {
                balanceElement.classList.add('lapsed-balance');
            } else {
                balanceElement.classList.remove('lapsed-balance');
            }
        }

        function formatDateForInput(date) {
            return date.toISOString().split('T')[0];
        }

        function formatDate(date) {
            const day = date.getDate().toString().padStart(2, '0');
            const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            const month = monthNames[date.getMonth()];
            const year = date.getFullYear();
            return `${day}-${month}-${year}`;
        }

        function formatDisplayDate(date) {
            const day = date.getDate();
            const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            const month = monthNames[date.getMonth()];
            const year = date.getFullYear();
            return `${day}-${month}-${year}`;
        }

        function formatAnniversaryDate(date) {
            const day = date.getDate();
            const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            const month = monthNames[date.getMonth()];
            const year = date.getFullYear();
            return `${month} ${day}, ${year}`;
        }

        function formatMMDDYYYY(date) {
            const day = date.getDate().toString().padStart(2, '0');
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const year = date.getFullYear();
            return `${month}/${day}/${year}`;
        }

        function extractFromImage() {
            const imageInput = document.getElementById('imageUpload');
            if (!imageInput.files.length) {
                alert('Please upload an image.');
                return;
            }

            const file = imageInput.files[0];
            Tesseract.recognize(file, 'eng', {
                logger: m => console.log(m)
            }).then(({ data: { text } }) => {
                console.log('Extracted Text:', text);

                // Extract client name
                const clientNameMatch = text.match(/CLIENT'S NAME:\s*([^\n]+)/);
                if (clientNameMatch) {
                    document.getElementById('clientName').value = clientNameMatch[1].trim();
                }

                // Extract plan name
                const planMatch = text.match(/Plan:\s*([^\n]+)/);
                if (planMatch) {
                    document.getElementById('planName').value = planMatch[1].trim();
                }

                // Extract policy number
                const policyNoMatch = text.match(/Policy No:\s*([0-9]+)/);
                if (policyNoMatch) {
                    document.getElementById('policyNo').value = policyNoMatch[1].trim();
                }

                // Extract policy anniversary
                const policyAnniversaryMatch = text.match(/Policy Anniversary:\s*([A-Za-z]+)\s*(\d{1,2}),?\s*(\d{4})/);
                if (policyAnniversaryMatch) {
                    const month = getMonthNumber(policyAnniversaryMatch[1]);
                    const day = policyAnniversaryMatch[2].padStart(2, '0');
                    const year = policyAnniversaryMatch[3];
                    document.getElementById('policyAnniversary').value = `${year}-${month}-${day}`;
                }

                // Try to extract MM/DD/YYYY format
                const mmddyyyyMatch = text.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})/);
                if (mmddyyyyMatch && !policyAnniversaryMatch) {
                    const month = mmddyyyyMatch[1].padStart(2, '0');
                    const day = mmddyyyyMatch[2].padStart(2, '0');
                    const year = mmddyyyyMatch[3];
                    document.getElementById('policyAnniversary').value = `${year}-${month}-${day}`;
                }

                // Extract total paid
                const totalPaidMatch = text.match(/Total paid for whole duration\s*PHP\s*([0-9,.]+)/);
                if (totalPaidMatch) {
                    document.getElementById('totalPaid').value = parseFloat(totalPaidMatch[1].replace(/,/g, ''));
                }

                // Extract premium amount (looking for the first premium amount in the table)
                const premiumAmountMatch = text.match(/PHP\s*([0-9,.]+\.[0-9]{2})/);
                if (premiumAmountMatch) {
                    document.getElementById('premiumAmount').value = parseFloat(premiumAmountMatch[1].replace(/,/g, ''));
                }

                // Try to determine payment mode based on coverage dates
                if (text.includes("15-Dec") || text.includes("15-Mar") || text.includes("15-Jun") || 
                    text.includes("28-Mar") || text.includes("28-Jun") || text.includes("28-Sep")) {
                    document.getElementById('modeOfPayment').value = 'quarterly';
                }
            });
        }

        function getMonthNumber(monthName) {
            const months = {
                "January": "01", "Jan": "01",
                "February": "02", "Feb": "02",
                "March": "03", "Mar": "03",
                "April": "04", "Apr": "04",
                "May": "05",
                "June": "06", "Jun": "06",
                "July": "07", "Jul": "07",
                "August": "08", "Aug": "08",
                "September": "09", "Sep": "09",
                "October": "10", "Oct": "10",
                "November": "11", "Nov": "11",
                "December": "12", "Dec": "12"
            };
            return months[monthName] || "01";
        }

        function generateSOA() {
            // Get input values
            const clientName = document.getElementById('clientName').value || "N/A";
            const planName = document.getElementById('planName').value || "N/A";
            const policyNo = document.getElementById('policyNo').value || "N/A";
            const policyAnniversary = new Date(document.getElementById('policyAnniversary').value);
            let totalPaid = parseFloat(document.getElementById('totalPaid').value) || 0;
            const periodPremium = parseFloat(document.getElementById('premiumAmount').value) || 0; // This is now per period
            const modeOfPayment = document.getElementById('modeOfPayment').value;
            const currentDate = new Date(document.getElementById('currentDate').value);
            const policyStatus = document.getElementById('policyStatus').value;
            const policyStatusText = document.getElementById('policyStatus').options[document.getElementById('policyStatus').selectedIndex].text;

            // Validate inputs
            if (!policyAnniversary || !periodPremium || !totalPaid) {
                alert('Please fill in at least the Policy Anniv., Total Paid and Premium Amount fields.');
                return;
            }

            // Calculate payment intervals and annual premium based on mode
            let intervalsPerYear;
            switch (modeOfPayment) {
                case 'quarterly':
                    intervalsPerYear = 4;
                    break;
                case 'monthly':
                    intervalsPerYear = 12;
                    break;
                default: // annual
                    intervalsPerYear = 1;
                    break;
            }
            
            // Calculate annual premium and interval amount
            const annualPremium = periodPremium * intervalsPerYear;
            const intervalAmount = periodPremium; // This is already per period

            // Generate coverage periods
            const coveragePeriods = [];
            let remainingPaid = totalPaid;
            let totalBalance = 0;
            let foundCurrentPeriod = false;
            
            // Start from the policy anniversary
            let startYear = policyAnniversary.getFullYear();
            let startMonth = policyAnniversary.getMonth();
            let startDay = policyAnniversary.getDate();
            
            // Calculate current policy year
            const currentPolicyYear = currentDate.getFullYear() - startYear + 
                (currentDate.getMonth() > startMonth || 
                (currentDate.getMonth() === startMonth && currentDate.getDate() >= startDay) ? 0 : -1);
            
            // Generate periods for past years (annual only)
            for (let year = 0; year < currentPolicyYear; year++) {
                const periodStartYear = startYear + year;
                const startDate = new Date(periodStartYear, startMonth, startDay);
                const endDate = new Date(periodStartYear + 1, startMonth, startDay);
                
                // Calculate payment status
                let status, statusText, amountPaid = 0;
                
                if (remainingPaid >= annualPremium) {
                    status = 'PAID';
                    statusText = 'PAID';
                    amountPaid = annualPremium;
                    remainingPaid -= annualPremium;
                } else if (remainingPaid > 0) {
                    status = 'PARTIAL';
                    amountPaid = remainingPaid;
                    const balance = annualPremium - remainingPaid;
                    
                    // Fix for "PAID 0.00 with balance X" issue
                    if (amountPaid === 0 || amountPaid < 0.01) {
                        status = 'NOT_PAID';
                        statusText = 'NOT PAID';
                    } else {
                        statusText = `PAID ${amountPaid.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})} with balance ${balance.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                    }
                    
                    totalBalance += balance;
                    remainingPaid = 0;
                } else {
                    status = 'NOT_PAID';
                    statusText = 'NOT PAID';
                    totalBalance += annualPremium;
                }
                
                coveragePeriods.push({
                    startDate,
                    endDate,
                    amount: annualPremium,
                    status,
                    statusText,
                    amountPaid,
                    containsCurrentDate: false,
                    afterCurrentPeriod: false
                });
            }
            
            // Generate periods for current year (broken down by mode of payment)
            const currentPeriodStartYear = startYear + currentPolicyYear;
            
            if (modeOfPayment === 'annual') {
                // For annual payments, create one period for current year
                const startDate = new Date(currentPeriodStartYear, startMonth, startDay);
                const endDate = new Date(currentPeriodStartYear + 1, startMonth, startDay);
                
                // Check if this period contains the current date
                const containsCurrentDate = currentDate >= startDate && currentDate < endDate;
                if (containsCurrentDate) {
                    foundCurrentPeriod = true;
                }
                
                // Calculate payment status
                let status, statusText, amountPaid = 0;
                
                if (remainingPaid >= annualPremium) {
                    status = 'PAID';
                    statusText = 'PAID';
                    amountPaid = annualPremium;
                    remainingPaid -= annualPremium;
                } else if (remainingPaid > 0) {
                    status = 'PARTIAL';
                    amountPaid = remainingPaid;
                    const balance = annualPremium - remainingPaid;
                    
                    // Fix for "PAID 0.00 with balance X" issue
                    if (amountPaid === 0 || amountPaid < 0.01) {
                        status = 'NOT_PAID';
                        statusText = 'NOT PAID';
                    } else {
                        statusText = `PAID ${amountPaid.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})} with balance ${balance.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                    }
                    
                    // Only add to balance if this is the current period or before
                    if (!foundCurrentPeriod || containsCurrentDate) {
                        totalBalance += balance;
                    }
                    
                    remainingPaid = 0;
                } else {
                    status = 'NOT_PAID';
                    statusText = 'NOT PAID';
                    
                    // Only add to balance if this is the current period or before
                    if (!foundCurrentPeriod || containsCurrentDate) {
                        totalBalance += annualPremium;
                    }
                }
                
                // Add future due indicator if this period contains the current date
                if (containsCurrentDate && status !== 'PAID') {
                    statusText += ', FUTURE DUE';
                }
                
                coveragePeriods.push({
                    startDate,
                    endDate,
                    amount: annualPremium,
                    status,
                    statusText,
                    amountPaid,
                    containsCurrentDate,
                    afterCurrentPeriod: false
                });
            } else {
                // For quarterly/monthly payments, create multiple periods for current year
                const monthsPerInterval = 12 / intervalsPerYear;
                
                for (let i = 0; i < intervalsPerYear; i++) {
                    const intervalStartDate = new Date(currentPeriodStartYear, startMonth + (i * monthsPerInterval), startDay);
                    const intervalEndDate = new Date(
                        i === intervalsPerYear - 1 
                            ? currentPeriodStartYear + 1 
                            : currentPeriodStartYear, 
                        i === intervalsPerYear - 1 
                            ? startMonth 
                            : startMonth + ((i + 1) * monthsPerInterval), 
                        startDay
                    );
                    
                    // Check if this period contains the current date
                    const containsCurrentDate = currentDate >= intervalStartDate && currentDate < intervalEndDate;
                    const afterCurrentPeriod = foundCurrentPeriod;
                    
                    if (containsCurrentDate) {
                        foundCurrentPeriod = true;
                    }
                    
                    // Calculate payment status
                    let status, statusText, amountPaid = 0;
                    
                    if (remainingPaid >= intervalAmount) {
                        status = 'PAID';
                        statusText = 'PAID';
                        amountPaid = intervalAmount;
                        remainingPaid -= intervalAmount;
                    } else if (remainingPaid > 0) {
                        status = 'PARTIAL';
                        amountPaid = remainingPaid;
                        const balance = intervalAmount - remainingPaid;
                        
                        // Fix for "PAID 0.00 with balance X" issue
                        if (amountPaid === 0 || amountPaid < 0.01) {
                            status = 'NOT_PAID';
                            statusText = 'NOT PAID';
                        } else {
                            statusText = `PAID ${amountPaid.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})} with balance ${balance.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                        }
                        
                        // Only add to balance if this is the current period or before
                        if (!afterCurrentPeriod) {
                            totalBalance += balance;
                        }
                        
                        remainingPaid = 0;
                    } else {
                        status = 'NOT_PAID';
                        statusText = 'NOT PAID';
                        
                        // Only add to balance if this is the current period or before
                        if (!afterCurrentPeriod) {
                            totalBalance += intervalAmount;
                        }
                    }
                    
                    // Add future due indicator only if this period contains the current date
                    if (containsCurrentDate && status !== 'PAID') {
                        statusText += ', FUTURE DUE';
                    }
                    
                    coveragePeriods.push({
                        startDate: intervalStartDate,
                        endDate: intervalEndDate,
                        amount: intervalAmount,
                        status,
                        statusText,
                        amountPaid,
                        containsCurrentDate,
                        afterCurrentPeriod
                    });
                }
            }

            // Generate HTML output with instruction box for editable status
            let output = `
                <div class="instruction-box">
                    <h4>Editable Status Column</h4>
                    <p>The "Status" column in the table below is editable. You can:</p>
                    <ul>
                        <li>Click on any status to edit it</li>
                        <li>Press Enter to save your changes</li>
                        <li>Press Escape to cancel</li>
                    </ul>
                    <p><strong>Your edits will be included when you export to PDF.</strong></p>
                </div>
                
                <div class="account-summary">
                    <h3>ACCOUNT SUMMARY</h3>
                    <div class="summary-row">
                        <div class="summary-label"><strong>CLIENT:</strong> ${clientName}</div>
                        <div class="summary-value"><strong>Total paid:</strong> PHP ${totalPaid.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</div>
                    </div>
                    <div class="summary-row">
                        <div class="summary-label"><strong>Plan:</strong> ${planName}</div>
                        <div class="summary-value"><strong>Balance</strong> PHP ${totalBalance.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</div>
                    </div>
                    <div class="summary-row">
                        <div class="summary-label"><strong>Policy No:</strong> ${policyNo}</div>
                    </div>
                    <div class="summary-row">
                        <div class="summary-label"><strong>Policy Anniversary:</strong> ${formatDisplayDate(policyAnniversary)}</div>
                    </div>
                    <div class="summary-row">
                        <div class="summary-label"><strong>Policy Status:</strong> ${policyStatusText}</div>
                    </div>
                </div>
                
                <table>
                    <thead>
                        <tr>
                            <th>Coverage Date</th>
                            <th>Premium Amount</th>
                            <th>Status <span style="font-size: 12px; font-weight: normal;">(click to edit)</span></th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            // Add coverage periods to table
            coveragePeriods.forEach(period => {
                const startDateStr = formatDisplayDate(period.startDate);
                const endDateStr = formatDisplayDate(period.endDate);
                const amountStr = `PHP ${period.amount.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                
                let statusClass = '';
                if (period.status === 'PAID') statusClass = 'paid';
                else if (period.status === 'PARTIAL') statusClass = 'partial-paid';
                else statusClass = 'not-paid';
                
                if (period.statusText.includes('FUTURE DUE')) statusClass += ' future-due';
                
                output += `
                    <tr>
                        <td>${startDateStr} to ${endDateStr}</td>
                        <td>${amountStr}</td>
                        <td class="${statusClass} editable-status" data-original-status="${period.statusText}">${period.statusText}</td>
                    </tr>
                `;
            });

            output += `
                    </tbody>
                </table>
            `;

            document.getElementById('output').innerHTML = output;
            
            // Also update the PDF container with the data
            updatePdfContainer(clientName, planName, policyNo, policyAnniversary, totalPaid, totalBalance, coveragePeriods, currentDate, policyStatus, policyStatusText);
        }
        
        // Function to update the PDF container with data
function updatePdfContainer(clientName, planName, policyNo, policyAnniversary, totalPaid, totalBalance, coveragePeriods, currentDate, policyStatus, policyStatusText) {
    // Set header image based on selection
    const headerImageSource = document.getElementById('headerImageSource').value;
    let headerImageUrl;
    
    if (headerImageSource === 'custom') {
        headerImageUrl = document.getElementById('headerImageUrl').value;
    } else if (headerImageSource === 'upload') {
        const headerImageUpload = document.getElementById('headerImageUpload');
        if (headerImageUpload.files.length > 0) {
            headerImageUrl = document.getElementById('headerImagePreview').src;
        } else {
            // Default fallback image
            headerImageUrl = "soa-header-image.png";
        }
    } else {
        // Default image
        headerImageUrl = "soa-header-image.png";
    }
    
    // Set the image in the PDF container
    const headerImg = document.getElementById('pdf-header-img');
    headerImg.src = headerImageUrl;
    
    // Set client info
    document.getElementById('pdf-client-name').textContent = clientName;
    document.getElementById('pdf-plan').textContent = planName;
    document.getElementById('pdf-policy-no').textContent = policyNo;
    document.getElementById('pdf-anniversary').textContent = formatAnniversaryDate(policyAnniversary);
    document.getElementById('pdf-policy-status').textContent = policyStatusText;
    
    // Set payment info
    document.getElementById('pdf-total-paid').textContent = `PHP ${totalPaid.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
    
    // Set balance amount and apply red color if policy is lapsed
    const balanceElement = document.getElementById('pdf-balance');
    balanceElement.textContent = `PHP ${totalBalance.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
    
    if (policyStatus === 'lapsed') {
        balanceElement.classList.add('lapsed-balance');
    } else {
        balanceElement.classList.remove('lapsed-balance');
    }
    
    // Set table rows
    const tableBody = document.getElementById('pdf-table-body');
    tableBody.innerHTML = '';
    
    // Get payment mode
    const modeOfPayment = document.getElementById('modeOfPayment').value;
    
    // Group periods by year for annual mode
    if (modeOfPayment === 'annual') {
        coveragePeriods.forEach((period, index) => {
            // Create data row
            const dataRow = document.createElement('tr');
            dataRow.className = 'data-row';
            
            const dateCell = document.createElement('td');
            dateCell.textContent = `${formatDisplayDate(period.startDate)} to ${formatDisplayDate(period.endDate)}`;
            
            const amountCell = document.createElement('td');
            amountCell.textContent = `PHP ${period.amount.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
            
            const statusCell = document.createElement('td');
            
            // Format status text with proper commas for amounts
            let statusText = period.statusText;
            if (period.status === 'PARTIAL') {
                const paidMatch = statusText.match(/PAID\s+(\d+\.\d+)/);
                const balanceMatch = statusText.match(/balance\s+(\d+\.\d+)/);
                
                if (paidMatch && balanceMatch) {
                    const paidAmount = parseFloat(paidMatch[1]);
                    const balanceAmount = parseFloat(balanceMatch[1]);
                    
                    statusText = `PAID ${paidAmount.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})} with balance ${balanceAmount.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                    
                    if (period.statusText.includes('FUTURE DUE')) {
                        statusText += ', FUTURE DUE';
                    }
                }
            }
            
            statusCell.textContent = statusText;
            
            dataRow.appendChild(dateCell);
            dataRow.appendChild(amountCell);
            dataRow.appendChild(statusCell);
            
            tableBody.appendChild(dataRow);
            
            // Add separator row after each entry except the last one
            if (index < coveragePeriods.length - 1) {
                const separatorRow = document.createElement('tr');
                separatorRow.className = 'separator-row';
                const separatorCell = document.createElement('td');
                separatorCell.colSpan = 3;
                separatorCell.innerHTML = '&nbsp;';
                separatorRow.appendChild(separatorCell);
                tableBody.appendChild(separatorRow);
            }
        });
        
        // Add final separator row at the end
        const finalSeparatorRow = document.createElement('tr');
        finalSeparatorRow.className = 'separator-row';
        const finalSeparatorCell = document.createElement('td');
        finalSeparatorCell.colSpan = 3;
        finalSeparatorCell.innerHTML = '&nbsp;';
        finalSeparatorRow.appendChild(finalSeparatorCell);
        tableBody.appendChild(finalSeparatorRow);
    } else {
        // For quarterly/monthly, group by policy year
        let currentYear = null;
        let currentPolicyYear = null;
        
        // First, identify the policy years and group the periods
        const policyYears = {};
        
        coveragePeriods.forEach(period => {
            // Create a unique identifier for the policy year based on anniversary date
            const policyAnnivMonth = policyAnniversary.getMonth();
            const policyAnnivDay = policyAnniversary.getDate();
            
            // Determine which policy year this period belongs to
            let periodPolicyYear;
            if (period.startDate.getMonth() > policyAnnivMonth || 
                (period.startDate.getMonth() === policyAnnivMonth && period.startDate.getDate() >= policyAnnivDay)) {
                periodPolicyYear = period.startDate.getFullYear();
            } else {
                periodPolicyYear = period.startDate.getFullYear() - 1;
            }
            
            // Add to the appropriate policy year group
            if (!policyYears[periodPolicyYear]) {
                policyYears[periodPolicyYear] = [];
            }
            policyYears[periodPolicyYear].push(period);
        });
        
        // Now render the periods by policy year with separators only between years
        const sortedYears = Object.keys(policyYears).sort();
        
        sortedYears.forEach((year, yearIndex) => {
            const periodsInYear = policyYears[year];
            
            // Add all periods for this policy year
            periodsInYear.forEach((period, periodIndex) => {
                // Create data row
                const dataRow = document.createElement('tr');
                dataRow.className = 'data-row';
                
                const dateCell = document.createElement('td');
                dateCell.textContent = `${formatDisplayDate(period.startDate)} to ${formatDisplayDate(period.endDate)}`;
                
                const amountCell = document.createElement('td');
                amountCell.textContent = `PHP ${period.amount.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                
                const statusCell = document.createElement('td');
                
                // Format status text with proper commas for amounts
                let statusText = period.statusText;
                if (period.status === 'PARTIAL') {
                    const paidMatch = statusText.match(/PAID\s+(\d+\.\d+)/);
                    const balanceMatch = statusText.match(/balance\s+(\d+\.\d+)/);
                    
                    if (paidMatch && balanceMatch) {
                        const paidAmount = parseFloat(paidMatch[1]);
                        const balanceAmount = parseFloat(balanceMatch[1]);
                        
                        statusText = `PAID ${paidAmount.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})} with balance ${balanceAmount.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                        
                        if (period.statusText.includes('FUTURE DUE')) {
                            statusText += ', FUTURE DUE';
                        }
                    }
                }
                
                statusCell.textContent = statusText;
                
                dataRow.appendChild(dateCell);
                dataRow.appendChild(amountCell);
                dataRow.appendChild(statusCell);
                
                tableBody.appendChild(dataRow);
            });
            
            // Add separator row after each policy year (except the last one)
            if (yearIndex < sortedYears.length - 1) {
                const yearSeparatorRow = document.createElement('tr');
                yearSeparatorRow.className = 'separator-row';
                const yearSeparatorCell = document.createElement('td');
                yearSeparatorCell.colSpan = 3;
                yearSeparatorCell.innerHTML = '&nbsp;';
                yearSeparatorRow.appendChild(yearSeparatorCell);
                tableBody.appendChild(yearSeparatorRow);
            }
        });
        
        // Add final separator row at the end
        const finalSeparatorRow = document.createElement('tr');
        finalSeparatorRow.className = 'separator-row';
        const finalSeparatorCell = document.createElement('td');
        finalSeparatorCell.colSpan = 3;
        finalSeparatorCell.innerHTML = '&nbsp;';
        finalSeparatorRow.appendChild(finalSeparatorCell);
        tableBody.appendChild(finalSeparatorRow);
    }
    
    // Update the PDF table with any edited status values from the main table
    updatePdfTableWithEditedStatus();
}
        
        // Function to export the SOA to PDF
        function exportToPDF() {
            // Make sure SOA is generated first
            if (!document.getElementById('output').innerHTML) {
                alert('Please generate the SOA first before exporting to PDF.');
                return;
            }
            
            // Update the PDF table with any edited status values
            updatePdfTableWithEditedStatus();
            
            // Show loading indicator
            document.getElementById('loading').style.display = 'block';
            
            // Get the PDF container
            const pdfContainer = document.getElementById('pdf-container');
            
            // Make sure the container is visible for html2canvas
            pdfContainer.style.display = 'block';
            
            // Create a new image element to preload the header image
            const preloadImg = new Image();
            preloadImg.crossOrigin = "Anonymous"; // Important for CORS
            
            // Get the header image URL
            const headerImg = document.getElementById('pdf-header-img');
            const headerImageUrl = headerImg.src;
            
            preloadImg.onload = function() {
                // Replace the header image with the preloaded one
                headerImg.src = preloadImg.src;
                
                // Wait a moment to ensure the DOM is updated
                setTimeout(function() {
                    // Use html2canvas to capture the PDF container
                    html2canvas(pdfContainer, {
                        scale: 2, // Higher scale for better quality
                        useCORS: true, // Allow loading cross-origin images
                        logging: false,
                        allowTaint: true, // Allow tainted canvas
                        backgroundColor: "white" // Ensure white background
                    }).then(canvas => {
                        // Hide the PDF container again
                        pdfContainer.style.display = 'none';
                        
                        // Create PDF with letter size (8.5" x 11")
                        const { jsPDF } = window.jspdf;
                        const pdf = new jsPDF({
                            orientation: 'portrait',
                            unit: 'in',
                            format: 'letter' // Use letter size (8.5" x 11")
                        });
                        
                        const imgData = canvas.toDataURL('image/png');
                        const imgWidth = 8.5; // Letter width in inches
                        const imgHeight = canvas.height * imgWidth / canvas.width;
                        
                        pdf.addImage(imgData, 'PNG', 0, 0, imgWidth, imgHeight);
                        
                        // Get client name for filename
                        const clientName = document.getElementById('clientName').value || "Client";
                        
                        // Save the PDF with client name in filename
                        pdf.save(`STATEMENT OF ACCOUNT - ${clientName}.pdf`);
                        
                        // Hide loading indicator
                        document.getElementById('loading').style.display = 'none';
                    }).catch(error => {
                        console.error('Error generating PDF:', error);
                        alert('Error generating PDF. Please check console for details.');
                        pdfContainer.style.display = 'none';
                        document.getElementById('loading').style.display = 'none';
                    });
                }, 500);
            };
            
            preloadImg.onerror = function() {
                console.error('Error loading header image');
                alert('Error loading header image. Using a placeholder instead.');
                
                // Use a simple placeholder image instead
                headerImg.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==";
                
                // Try again with the placeholder
                setTimeout(function() {
                    exportToPDF();
                }, 100);
            };
            
            // Start loading the image
            preloadImg.src = headerImageUrl;
        }
    </script>
</body>
</html>